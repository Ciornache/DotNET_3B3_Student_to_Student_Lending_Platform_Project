<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/REFRESH_TOKEN_IMPLEMENTATION.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/REFRESH_TOKEN_IMPLEMENTATION.md" />
              <option name="updatedContent" value="# Refresh Token Rotation and Reuse Detection Implementation&#10;&#10;## Overview&#10;I've successfully implemented Refresh Token Rotation with Reuse Detection for your authentication system. Here's what was added:&#10;&#10;## Changes Made&#10;&#10;### 1. RefreshToken Entity Updates (`Data/RefreshToken.cs`)&#10;Added new properties to support token families and rotation:&#10;- **`TokenFamily`** (Guid): Unique identifier shared by all tokens in a rotation chain&#10;- **`ParentTokenId`** (Guid?): Reference to the parent token that was exchanged to create this token (null for initial login tokens)&#10;- **`ReplacedByTokenId`** (Guid?): Reference to the child token created by exchanging this token (null if not yet rotated)&#10;- **`ReasonRevoked`** (string?): Reason why the token was revoked (e.g., &quot;Token reuse detected&quot;, &quot;User re-authenticated&quot;, &quot;Rotated to new token&quot;)&#10;&#10;### 2. LoginUserHandler Updates&#10;When a user logs in:&#10;- **Revokes all existing refresh tokens** for that user (invalidates all active sessions)&#10;- Creates a **new token family** (Guid.NewGuid()) for the new login session&#10;- Stores the initial refresh token with `ParentTokenId = null` and the new family ID&#10;&#10;This ensures that when users re-authenticate, all previous sessions are terminated.&#10;&#10;### 3. RefreshTokenHandler Updates&#10;Implements the core rotation and reuse detection logic:&#10;&#10;#### Token Rotation&#10;- When a valid refresh token is used, it's marked as revoked with reason &quot;Rotated to new token&quot;&#10;- A new refresh token is generated with:&#10;  - Same `TokenFamily` as the parent&#10;  - `ParentTokenId` pointing to the old token&#10;  - Old token's `ReplacedByTokenId` updated to point to the new token&#10;- Both access and refresh tokens are returned&#10;&#10;#### Reuse Detection&#10;- If a token that's already revoked (but not expired) is presented, it triggers **family invalidation**&#10;- The `RevokeTokenFamily()` method revokes ALL tokens in that family&#10;- Reason set to: &quot;Token reuse detected - potential security breach&quot;&#10;- Returns Unauthorized status&#10;&#10;This protects against:&#10;- **Token theft**: If an attacker steals a token and uses it, the legitimate user's next rotation will invalidate the attacker's token chain&#10;- **Replay attacks**: Reusing an old token in the chain immediately locks down the entire family&#10;&#10;### 4. New Endpoint: Get Refresh Tokens by Email&#10;**Endpoint**: `GET /users/{email}/refresh-tokens`&#10;&#10;Returns all refresh tokens for a user, showing:&#10;- Token ID, creation time, expiration time&#10;- Revocation status and reason&#10;- Token family, parent/child relationships&#10;- Whether the token is expired&#10;&#10;**Files created**:&#10;- `GetRefreshTokensByEmailRequest.cs`&#10;- `GetRefreshTokensByEmailHandler.cs`&#10;&#10;### 5. Updated Program.cs&#10;- Registered `GetRefreshTokensByEmailHandler` in DI container&#10;- Added the new endpoint mapping&#10;&#10;## How It Works&#10;&#10;### Scenario 1: Normal Token Rotation&#10;1. User logs in → Token Family A is created with Token 1&#10;2. Token 1 is used to refresh → Token 1 revoked, Token 2 created (same family A)&#10;3. Token 2 is used to refresh → Token 2 revoked, Token 3 created (same family A)&#10;4. Chain continues: Token 1 → Token 2 → Token 3 → Token 4...&#10;&#10;### Scenario 2: Token Reuse Detection (Attack)&#10;1. User logs in → Token Family A is created with Token 1&#10;2. Token 1 is used to refresh → Token 1 revoked, Token 2 created&#10;3. **Attacker tries to reuse Token 1** (already revoked)&#10;4. System detects reuse → **Entire Family A is revoked** (Token 1, Token 2, and any others)&#10;5. Attacker is locked out, legitimate user must re-authenticate&#10;&#10;### Scenario 3: Re-authentication&#10;1. User has active sessions with multiple devices (different token families)&#10;2. User logs in again&#10;3. **All existing tokens across all families are revoked**&#10;4. New Token Family B is created&#10;5. Old sessions are terminated, only new session is valid&#10;&#10;## Database Migration Required&#10;&#10;**IMPORTANT**: You need to create and apply a migration for these changes.&#10;&#10;Run these commands (after stopping the running application):&#10;&#10;```bash&#10;dotnet ef migrations add AddRefreshTokenRotationAndFamily --project &quot;F:\General Info\Anul III\DOT Net\DotNET_3B3_Student_to_Student_Lending_Platform_Project\Backend&quot;&#10;&#10;dotnet ef database update --project &quot;F:\General Info\Anul III\DOT Net\DotNET_3B3_Student_to_Student_Lending_Platform_Project\Backend&quot;&#10;```&#10;&#10;## Security Benefits&#10;&#10;1. **Token Reuse Detection**: Automatically detects and responds to stolen tokens&#10;2. **Rotation**: Each token can only be used once, reducing attack surface&#10;3. **Family Tracking**: Can trace and invalidate entire token chains&#10;4. **Session Termination**: Re-authentication invalidates all previous sessions&#10;5. **Audit Trail**: `ReasonRevoked` provides forensic information&#10;&#10;## Testing the Implementation&#10;&#10;1. Register/login a user → receive refresh token (Family A, Token 1)&#10;2. Use refresh endpoint → get new tokens (Family A, Token 2)&#10;3. Try to reuse Token 1 → should get Unauthorized, Family A invalidated&#10;4. Check tokens via `GET /users/{email}/refresh-tokens` → see the revocation chain&#10;&#10;## Notes&#10;&#10;- All files compile successfully with no errors&#10;- The implementation follows the existing non-MediatR pattern&#10;- Token families are tracked in the database with parent-child relationships&#10;- Expired tokens don't trigger reuse detection (they're just rejected normally)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>